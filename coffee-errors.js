// Generated by CoffeeScript 1.6.3
var coffee, compile, compileFile, ext, extensions, formatSourcePosition, fs, getSourceMap, helpers, loadFile, patchStackTrace, patched, path, sourceMaps, _i, _len,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

helpers = require('coffee-script/lib/coffee-script/helpers');

coffee = require('coffee-script');

if (parseInt(coffee.VERSION.replace(/\D+/g, '')) < 162) {
  throw new Error('`coffee-errors` expects `coffee-script@~1.6.2`');
}

compile = coffee.compile;

patched = false;

extensions = ['.coffee', '.litcoffee', '.coffee.md'];

sourceMaps = {};

patchStackTrace = function() {
  var oldPrepareStackTrack;
  if (patched) {
    return;
  }
  patched = true;
  oldPrepareStackTrack = Error.prepareStackTrace;
  return Error.prepareStackTrace = function(err, stack) {
    var e, frame, frames, getSourceMapping, sourceFiles, _ref;
    try {
      sourceFiles = {};
      getSourceMapping = function(filename, line, column) {
        var answer, sourceMap;
        sourceMap = getSourceMap(filename);
        if (sourceMap) {
          answer = sourceMap.sourceLocation([line - 1, column - 1]);
        }
        if (answer) {
          return [answer[0] + 1, answer[1] + 1];
        } else {
          return null;
        }
      };
      frames = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = stack.length; _i < _len; _i++) {
          frame = stack[_i];
          if (frame.getFunction() === coffee.run) {
            break;
          }
          _results.push("  at " + (formatSourcePosition(frame, getSourceMapping)));
        }
        return _results;
      })();
      return "" + err.name + ": " + ((_ref = err.message) != null ? _ref : '') + "\n" + (frames.join('\n')) + "\n";
    } catch (_error) {
      e = _error;
      Error.prepareStackTrace = oldPrepareStackTrack;
      "`coffee-errors` failed during stack parsing, falling back onto the previous parser. " + err.stack;
      return err.stack;
    }
  };
};

formatSourcePosition = function(frame, getSourceMapping) {
  var as, column, fileLocation, fileName, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;
  fileName = void 0;
  fileLocation = '';
  if (frame.isNative()) {
    fileLocation = "native";
  } else {
    if (frame.isEval()) {
      fileName = frame.getScriptNameOrSourceURL();
      if (!fileName) {
        fileLocation = "" + (frame.getEvalOrigin()) + ", ";
      }
    } else {
      fileName = frame.getFileName();
    }
    fileName || (fileName = "<anonymous>");
    line = frame.getLineNumber();
    column = frame.getColumnNumber();
    source = getSourceMapping(fileName, line, column);
    fileLocation = source ? "" + fileName + ":" + source[0] + ":" + source[1] : "" + fileName + ":" + line + ":" + column;
  }
  functionName = frame.getFunctionName();
  isConstructor = frame.isConstructor();
  isMethodCall = !(frame.isToplevel() || isConstructor);
  if (isMethodCall) {
    methodName = frame.getMethodName();
    typeName = frame.getTypeName();
    if (functionName) {
      tp = as = '';
      if (typeName && functionName.indexOf(typeName)) {
        tp = "" + typeName + ".";
      }
      if (methodName && functionName.indexOf("." + methodName) !== functionName.length - methodName.length - 1) {
        as = " [as " + methodName + "]";
      }
      return "" + tp + functionName + as + " (" + fileLocation + ")";
    } else {
      return "" + typeName + "." + (methodName || '<anonymous>') + " (" + fileLocation + ")";
    }
  } else if (isConstructor) {
    return "new " + (functionName || '<anonymous>') + " (" + fileLocation + ")";
  } else if (functionName) {
    return "" + functionName + " (" + fileLocation + ")";
  } else {
    return fileLocation;
  }
};

compileFile = function(filename, sourceMap) {
  var answer, err, raw, stripped;
  raw = fs.readFileSync(filename, 'utf8');
  stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;
  try {
    answer = compile(stripped, {
      filename: filename,
      sourceMap: sourceMap,
      literate: helpers.isLiterate(filename)
    });
  } catch (_error) {
    err = _error;
    err.filename = filename;
    err.code = stripped;
    throw err;
  }
  return answer;
};

getSourceMap = function(filename) {
  var answer, _ref;
  if (sourceMaps[filename]) {
    return sourceMaps[filename];
  }
  if (_ref = path.extname(filename), __indexOf.call(extensions, _ref) < 0) {
    return;
  }
  answer = compileFile(filename, true);
  return sourceMaps[filename] = answer.sourceMap;
};

loadFile = function(module, filename) {
  var answer;
  answer = compileFile(filename, false);
  return module._compile(answer, filename);
};

if (require.extensions) {
  for (_i = 0, _len = extensions.length; _i < _len; _i++) {
    ext = extensions[_i];
    require.extensions[ext] = loadFile;
  }
}

patchStackTrace();
